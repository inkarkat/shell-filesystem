#!/bin/bash
shopt -qs extglob nullglob

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" "[SORT-ARGS ...] [-d|--include-directories|-r|--recursive] [-a|--after FILE|'FILE-GLOB' [...] [-C|--count-if-sentinel-missing N] | -c|--count N] [-o|--offset N] [--] [DIRSPEC|FILESPEC [...]] [-?|-h|--help]"
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Print the filespecs of the alphabetically last file(s) in the current directory
/ in each passed DIRSPEC / within each passed FILESPEC, considering only the
filename itself (i.e. ignoring any path components, except to determine the
precedence for identical filenames).
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --include-directories|-d
			    Also consider directories in the current directory /
			    the single passed DIRSPEC / of the passed
			    DIRSPEC|FILESPEC. By default, only files are
			    considered.
    --recursive|-r	    Consider the current directory tree / subdirectories
			    with any nesting within DIRSPEC(s).
    --after|-a FILE|'FILE-GLOB'
			    Print all files that alphabetically come after FILE
			    (ignoring any path components) / the last file
			    matching FILE-GLOB (if the directory has such a
			    file).
    --count-if-sentinel-missing|-C N
			    Print the last N files (or fewer if not available)
			    if no sentinel FILE|'FILE-GLOB' exists.
    --count|-c N	    Print the last N files (or fewer if not available)
			    instead of just the last one.
    --offset|-o N	    Skip the last N file(s). This is applied before
			    --count.
SEE ALSO:
- truncateDir builds the inverse set of files can remove those first files.

EXIT STATUS:
    0	Complete success.
    1	No files found.
    2	Bad invocation, wrong or missing command-line arguments.
    4	No sentinel FILE|'FILE-GLOB' exists (so files cannot be searched) (and
	--count-if-sentinel-missing has not been passed).
HELPTEXT
}

directoryStrategy=ignore
typeset -a globs=()
sentinelMissingCount=
unset count
typeset -a offsetter=()
typeset -a sortArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--include-directories|-d)
			shift; directoryStrategy=include;;
	--recursive|-r)	shift; directoryStrategy=recurse;;
	--after|-a)	shift; globs+=("$1"); shift;;
	--count-if-sentinel-missing|-C)
			shift; sentinelMissingCount="$1"; shift;;
	--count|-c)	shift; count="$1"; shift;;
	--offset|-o)	shift; offsetter=(head "-n-${1:?}"); shift;;

	-+([bdfgiMhnRrVs]))
			sortArgs+=("$1"); shift;;
	--@(dictionary-order|general-numeric-sort|human-numeric-sort|ignore-case|ignore-leading-blanks|ignore-nonprinting|month-sort|numeric-sort|random-sort|reverse|stable|version-sort))
			sortArgs+=("$1"); shift;;
	-[kStT])	sortArgs+=("$1" "${2?}"); shift; shift;;
	--@(batch-size|buffer-size|field-separator|key|parallel|random-source|sort|temporary-directory))
			sortArgs+=("$1" "${2?}"); shift; shift;;

	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
IFS=$'\n'
if [ ${#globs[@]} -gt 0 ]; then
    if [ -n "${count+t}" ]; then
	echo 'ERROR: Cannot combine --after with --count.'
	echo
	printUsage "$0"
	exit 2
    fi >&2

    typeset -A sentinels=()
    readarray -t globbedFilespecs < <(expandglob -- "${globs[@]}")
    for globResult in "${globbedFilespecs[@]}"
    do
	[ -e "$globResult" ] && sentinels["${globResult##*/}"]=1
    done
    if [ ${#sentinels[@]} -eq 0 ]; then
	if [ -n "$sentinelMissingCount" ]; then
	    count=$sentinelMissingCount
	    globs=()
	else
	    exit 4
	fi
    fi
fi
[ $# -gt 0 ] || set -- "$PWD"
: ${count:=1}

findAfter()
{
    local i filename lastIndex=$((${#filespecs[@]} - 1))
    for ((i = lastIndex; i >= 0; i--))
    do
	filename="${filespecs[$i]##*/}" || continue
	[ -n "$filename" ] && [ "${sentinels["$filename"]}" ] && break
    done
    [ $i -ge 0 -a $i -lt $lastIndex ] || return 1
    printf '%s\n' "${filespecs[@]:$((i + 1))}"
}

findLast()
{
    lastIndex=$((${#filespecs[@]} - $count)); [ $lastIndex -lt 0 ] && lastIndex=0
    typeset -a lastFilespecs=("${filespecs[@]:$lastIndex}")
    [ ${#lastFilespecs[@]} -gt 0 ] || return 1
    printf '%s\n' "${lastFilespecs[@]}"
}

typeset -a basenameAndFilespecs=()
addFiles()
{
    local dirOrFile; for dirOrFile
    do
	if [ -d "$dirOrFile" ]; then
	    case "$directoryStrategy" in
		drop)	    ;;
		ignore)     if [ $# -eq 1 ]; then
				# CWD or single passed DIRSPEC: Include only files in it.
				directoryStrategy=drop
				addFiles "${dirOrFile%/}"/*
			    else
				# Multiple DIRSPEC|FILESPEC: Skip the directory itself.
				:
			    fi
			    ;;
		include)    if [ $# -eq 1 ]; then
				# CWD or single passed DIRSPEC: Include directories in it (once).
				for filespec in "${dirOrFile%/}"/*
				do
				    basenameAndFilespecs+=("${filespec##*/}/$filespec")
				done
			    else
				# Multiple DIRSPEC|FILESPEC: Include the directory itself.
				basenameAndFilespecs+=("${dirOrFile##*/}/$dirOrFile")
			    fi
			    ;;
		recurse)    addFiles "${dirOrFile%/}"/*;;
	    esac
	elif [ -e "$dirOrFile" ]; then
	    basenameAndFilespecs+=("${dirOrFile##*/}/$dirOrFile")
	fi
    done
}
addFiles "$@"
[ ${#basenameAndFilespecs[@]} -eq 0 ] && exit 1

readarray -t filespecs < <(
    printf '%s\n' "${basenameAndFilespecs[@]}" \
	| sort --unique "${sortArgs[@]}" \
	| eval 'cut -d / -f 2-' \
	"${offsetter:+|}" '"${offsetter[@]}"'
)

if [ ${#globs[@]} -gt 0 ]; then
    findAfter
else
    findLast
fi
