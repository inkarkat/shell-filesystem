#!/bin/bash
shopt -qs extglob nullglob dotglob

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
printf 'Usage: %q %s\n' "$(basename "$1")" "[STARTING-POINT [...]] [-1|--stop-at-first] [--mindepth LEVELS] [--maxdepth LEVELS] [--] FILE|'GLOB' [...] [-?|-h|--help]"
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Locate a FILE or matches for 'GLOB' in parent directories (from the current
directory or passed STARTING-POINT(s), up to the root directory), and print its
/ their full path(s).
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --stop-at-first|-1	Stop ascending further (and considering more
			STARTING-POINT(s)) once match(es) have been found in any
			upper directory.
    --maxdepth LEVELS	Ascend at most LEVELS of directories above the current
			directory.
    --mindepth LEVELS	Do not test at levels less than LEVELS. --mindepth 1
			means report any files except inside the current
			directory.
HELPTEXT
}
case "$1" in
    --help|-h|-\?)	shift; printUsage "$0"; exit 0;;
esac
typeset -a startingPoints=()
# As we change directories, need to first convert all passed starting points to
# absolute dirspecs.
while [ $# -ne 0 -a -d "$1" ]
do
    startingPoints+=("$(realpath --no-symlinks -- "$1")"); shift
done

isStopAtFirst=
maxdepth=
mindepth=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--stop-at-first|-1)
			shift; isStopAtFirst=t;;
	--maxdepth)	shift; maxdepth="$1"; shift;;
	--mindepth)	shift; mindepth="$1"; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printShortUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -eq 0 ]; then
    printUsage >&2 "$0"
    exit 2
fi

printMatches()
{
    [ "$mindepth" ] && [ $level -lt $mindepth ] && return 1
    [ "$maxdepth" ] && [ $level -gt $maxdepth ] && return 1

    printf "$@"
}
printGlobMatches()
{
    typeset -a files=($@)
    # If globbing didn't yield anything, we've failed.
    ((${#files[@]})) || return 1
    # Still need to check for existing files; in case a GLOB without a wildcard was
    # passed, it's not eliminated by nullglob.
    local status=1
    for f in "${files[@]}"
    do
	[ -e "$f" ] || continue
	printMatches '%s/%s\n' "${PWD%/}" "$f" && status=0
    done
    return $status
}

status=1
for baseDir in "${startingPoints[@]:-}"
do
    [ "$baseDir" ] && cd "$baseDir"

    oldWd=
    let level=0
    while [ "$oldWd" != "$PWD" ]
    do
	if printGlobMatches "$@" 2>/dev/null; then
	    [ "$isStopAtFirst" ] && exit 0
	    status=0
	fi
	oldWd="$PWD"
	cd .. || exit 3
	let level+=1
    done
done
exit $status
