#!/bin/bash

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-f|--overwrite|-k|--keep] [--delete-original] [--] FILE [...] [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-f|--overwrite|-k|--keep] [--delete-original] --ignore-no-files [--] [FILE [...]] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Write a single backup of FILE to FILE.orig. Ignores passed directories and
*.orig files.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --overwrite|-f		Overwrite an existing backup.
    --keep|-k			Do nothing if the backup already exists
				(default behavior).
    --delete-original		Removes the original FILE after creating
				FILE.orig; you can use this for a final backup
				before getting rid of the FILE.
    --ignore-no-files		Do not complain when no FILE(s) have been
				passed. Useful when passing a glob that may
				resolve to no files at all, and that is
				acceptable.
EXIT STATUS:
    0	Complete success.
    1	Failed to backup any file(s).
    2	Partial success; some file(s) could not be backed up.
    3	Bad invocation, wrong or missing command-line arguments.
HELPTEXT
}

isOverwrite=
isIgnoreNoFiles=
isDeleteOriginal=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--overwrite|-f)	shift; isOverwrite=t;;
	--keep|-k)	shift; isOverwrite=;;
	--ignore-no-files)
			shift; isIgnoreNoFiles=t;;
	--delete-original)
			shift; isDeleteOriginal=t;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"${1}\"!"; echo; printUsage "$0"; } >&2; exit 3;;
	*)		break;;
    esac
done
if [ $# -eq 0 ] && [ ! "$isIgnoreNoFiles" ]; then
    printUsage "$0" >&2
    exit 2
fi

writebackup()
{
    local -r filespec="$1"

    [[ "$filespec" = *.orig ]] && return 1  # Don't backup original files themselves; this allows passing a generic glob like * to it.

    if [ -f "$filespec" ]; then
	if [ ! -r "$filespec" ]; then
	    printf >&2 'ERROR: "%s" is not readable!\n' "$filespec"
	    return 1
	fi
	local -r backupFilespec="${filespec}.orig"
	if [ "${backupFilespec}" ]; then
	    if [ ! "$isOverwrite" ] && [ -f "$backupFilespec" ]; then
		return 1
	    fi

	    umask 0111	# Drop the execute permission on the backup.
	    cp -- "${filespec}" "${backupFilespec}" || return 1
	    printf 'Backed up to %s%s\n' "$backupDir" "$(basename -- "${backupFilespec}")"

	    if [ "$isDeleteOriginal" ]; then
		rm --force -- "${filespec}" || return 1
		printf 'Deleted original %s\n' "$filespec"
	    fi

	    return 0
	else
	    return 1
	fi
    elif [ -d "$filespec" ]; then
	# Ignore passed directories.
	return 1
    else
	printf >&2 'ERROR: "%s" does not exist!\n' "$filespec"
	return 1
    fi
}


isSuccess=
isFailure=

while [ $# -ne 0 ]
do
    writebackup "$1" && isSuccess=t || isFailure=t
    shift
done

if [ "$isFailure" ]; then
    [ "$isSuccess" ] && exit 2 || exit 1
fi
