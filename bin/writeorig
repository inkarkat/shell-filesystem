#!/bin/bash

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-f|--overwrite|-k|--keep] [--delete-original] [--] FILE|DIR [...] [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-f|--overwrite|-k|--keep] [--delete-original] --ignore-no-files [--] [FILE|DIR [...]] [-?|-h|--help]'
    echo
    printf 'Usage: sed -i"$(%q %s)" -e ... FILE|DIR\n' "$(basename "$1")" '[-f|--overwrite|-k|--keep] --get-extension [--accept-nonexisting] [--] FILE|DIR'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Write a single backup of FILE to FILE.orig. Ignores *.orig files.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --overwrite|-f		Overwrite an existing backup.
    --keep|-k			Do nothing if the backup already exists
				(default behavior).
    --delete-original		Removes the original FILE after creating
				FILE.orig; you can use this for a final backup
				before getting rid of the FILE.
    --ignore-no-files		Do not complain when no FILE(s) have been
				passed. Useful when passing a glob that may
				resolve to no files at all, and that is
				acceptable.
    --get-extension		Just print the .orig backup extension (or
				nothing if --keep and a backup already exists).
    --accept-nonexisting	Do not print an error if FILE does not exist,
				but simply print the would-be backup extension.
				Useful for direct-backup use cases where there's
				either no original file or it is located
				somewhere else.
EXIT STATUS:
    0	Complete success.
    1	Failed to backup any file(s).
    2	Partial success; some file(s) could not be backed up.
    3	Bad invocation, wrong or missing command-line arguments.
HELPTEXT
}

isOverwrite=
isIgnoreNoFiles=
isDeleteOriginal=
isOnlyPrintExtension=
isAcceptNonexisting=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--overwrite|-f)	shift; isOverwrite=t;;
	--keep|-k)	shift; isOverwrite=;;
	--ignore-no-files)
			shift; isIgnoreNoFiles=t;;
	--delete-original)
			shift; isDeleteOriginal=t;;
	--get-extension)
			shift; isOnlyPrintExtension=t;;
	--accept-nonexisting)
			shift; isAcceptNonexisting=t;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"${1}\"!"; echo; printUsage "$0"; } >&2; exit 3;;
	*)		break;;
    esac
done
if [ $# -eq 0 ] && [ ! "$isIgnoreNoFiles" ]; then
    printUsage "$0"
    exit 2
elif [ "$isOnlyPrintExtension" ] && [ $# -ne 1 ]; then
    echo 'ERROR: Only a single FILE|DIR can be passed with --get-extension.'
    echo
    printUsage "$0"
    exit 2
elif [ "$isOnlyPrintExtension" ] && [ "$isDeleteOriginal" ]; then
    echo 'ERROR: Cannot combine --get-extension and --delete-original.'
    echo
    printUsage "$0"
    exit 2
fi >&2

writebackup()
{
    local -r filespec="$1"

    [[ "$filespec" = *.orig ]] && return 1  # Don't backup original files themselves; this allows passing a generic glob like * to it.

    if [ -e "$filespec" ]; then
	if [ ! -r "$filespec" ]; then
	    printf >&2 'ERROR: "%s" is not readable!\n' "$filespec"
	    return 1
	fi
	local -r backupFilespec="${filespec}.orig"
	if [ "${backupFilespec}" ]; then
	    if [ ! "$isOverwrite" ] && [ -e "$backupFilespec" ]; then
		return 1
	    fi
	    if [ "$isOnlyPrintExtension" ]; then
		printf '%s\n' ".${backupFilespec##*.}"
		return 0
	    fi

	    if [ -f "$filespec" ]; then
		umask 0111	# Drop the execute permission on the backup.
		cp -- "${filespec}" "${backupFilespec}" || return 1
		printf 'Backed up to %s%s\n' "$backupDir" "$(basename -- "${backupFilespec}")"

		if [ "$isDeleteOriginal" ]; then
		    rm --force -- "${filespec}" || return 1
		    printf 'Deleted original %s\n' "$filespec"
		fi

		return 0
	    elif [ -d "$filespec" ]; then
		if [ "$isDeleteOriginal" ]; then
		    mv --force -- "${filespec}" "${backupFilespec}" || return 1
		    printf 'Moved original directory to %s%s\n' "$backupDir" "$(basename -- "${backupFilespec}")"
		else
		    cp --archive --no-target-directory --force -- "${filespec}" "${backupFilespec}" || return 1
		    printf 'Copied directory to %s%s\n' "$backupDir" "$(basename -- "${backupFilespec}")"
		fi
	    else
		# Ignore anything else?!
		return 1
	    fi
	else
	    return 1
	fi
    elif [ "$isOnlyPrintExtension" ] && [ "$isAcceptNonexisting" ]; then
	printf '.orig\n'
    else
	printf >&2 'ERROR: "%s" does not exist!\n' "$filespec"
	return 1
    fi
}


isSuccess=
isFailure=

for filespec
do
    writebackup "$filespec" && isSuccess=t || isFailure=t
done

if [ "$isFailure" ]; then
    [ "$isSuccess" ] && exit 2 || exit 1
fi
